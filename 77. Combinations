//Input: n = 4, k = 2
//Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
//Explanation: There are 4 choose 2 = 6 total combinations.
//Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.

class Solution {
public:
    void help(int i, int n, int k, vector<int> &subSet, vector<vector<int>> &ans)
    {
        // if k reaches 0 that means we got our array eg: [1,2] here k will 0 , reduced twice
        if (k == 0)                            
        {
            // we push our current subset into ans
            ans.push_back(subSet);             
            return;
        }
        // eg: n=4 i=3  k=3 =>  [1,2,3,4] i=3, elements left=[3,4], but k is 3,the length of the remaining elements should be greater than k
        if (k > n - i + 1)                     
            return;
        if (i > n)                          
            return;
        // insert current element into subset
        subSet.push_back(i);                   
        help(i + 1, n, k - 1, subSet, ans);     // reduce k by 1 since we are including current element
        // backtract by removing current element
        subSet.pop_back();
        help(i + 1, n, k, subSet, ans);         // k remains same as current element is not included in the subset
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> ans ;                 // stores final answer
        vector<int> subSet;
        help(1 , n , k , subSet , ans) ;
        return ans ;
    }
};
