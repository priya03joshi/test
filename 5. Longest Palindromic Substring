//Input: s = "babad"
//Output: "bab"
//Explanation: "aba" is also a valid answer.
//   0 1 2 3 4
//   b a b a d
// b 1 0 3 0 0
// a   1 0 3 0
// b     1 0 0
// a       1 0
// d         1
class Solution {
public:
    string longestPalindrome(string s) {
        int n=s.size();
        vector<vector<int>> dp(n,vector<int>(n,0));
        int maxLength=0;
        string maxString="";
        for(int diff=0;diff<n;diff++)
        {
            for(int i=0,j=i+diff;j<n;i++,j++)
            {
                // all diagonals will be 1 eg: a==a, b==b
                if(i==j)
                {
                    dp[i][j]=1;
                }
                // if j-i=1, then just check if both elements are equal of not eg: i=0 (b) j=1 (a)
                else if(diff==1)
                {
                    if(s[i]==s[j])
                    {
                        dp[i][j]=2;
                    }
                }
                // else check if both elements are equal and previous diagonal element is not 0
                // eg: i=0 (b), j=2 (b), these both are equal and previous diagonal value i+1=1, j-1=1 is 1 so it is palindrome
                else{
                    if(s[i]==s[j] && dp[i+1][j-1]!=0)
                    {
                        dp[i][j]=dp[i+1][j-1]+2;
                    }
                }
                if(dp[i][j]!=0)
                {
                    if(maxLength<j-i+1)
                    { 
                       maxLength=j-i+1;
                       maxString=s.substr(i,j-i+1);
                    }
                }
            }
        }
        return maxString;
    }
};
